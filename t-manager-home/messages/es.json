{
    "tManager" : "T-MANAGER",
    "home" : "> Inicio",
    "project" : "> Proyecto",
    "home.terminal.welcome" : "Bienvenido a la página de Txomin",
    "home.terminal.aim" : "Aquí encontrarás ayuda, tanto si eres un estudiante buscando ayuda en programación como si eres una pequeña empresa que busca una web o un POC",
    "home.terminal.help" : "Escribe 'help' para ver los comandos y tareas existentes",
    "home.terminal.clear" : "Escribe 'clear' si la pantalla se llena de demasiados datos",
    "home.terminal.error" : "Error",
    "home.terminal.commandNotRecognized" : "¡El comando no se reconoce!",
    "home.terminal.optionRequired" : "¡La opción es obligatoria!",
    "home.terminal.cat" : "Mostrar detalles, uso: cat ruta <div class='command-description'><p>Opciones:</p><p>*ruta -> about features prices txomin</p></div>",
    "home.terminal.sectionOpened" : "Sección abierta",
    "home.terminal.supportedCommands" : "Aquí está la lista de comandos soportados",
    "home.terminal.helpCommand" : "Introduce help <command> para recibir ayuda de un comando en particular",
    "home.terminal.links" : "Contacto",
    "home.terminal.done" : "Hecho",
    "home.projectMotivation" : "Sobre este proyecto",
    "home.projectMotivation.description" : "<p>Después de varios años, me he dado cuenta de que lo que más cuesta a un programador a la hora de empezar una aplicación es <b>EMPEZAR</b>, tanto por pereza, falta de recursos o tiempo. Con esta web lo que intento es ayudar a esos que necesitan ese pequeño empujón, ya sea de forma práctica o teórica.</p><p>Mi idea es ayudar a estudiantes o programadores con menos experiencia a asentar bien las bases de la programación orientada a objetos, con ejercicios prácticos y teóricos, ya que a veces la programación se puede atragantar si no se tienen claras las bases</p><p>Además, hago páginas web con <b>WORDPRESS</b> para quien necesite salir de un apuro (https://psk9.es/, https://helmuga.eu/ o https://carolinamosquera.es/).</p><p>Para pequeñas empresas o emprendedores, además facilito pruebas de concepto para que puedan llevar a cabo sus ideas como la desarrollada en http://investdividend.com/ y mi propio proyecto POC https://github.com/txomin55/t-manager-module.</p>",
    "home.projectFeatures" : "Características del proyecto",
    "home.projectFeatures.architecture" : "Arquitectura limpia",
    "home.projectFeatures.architecture.sub" : "Arquitectura hexagonal, para que la aplicación en su parte de backend tenga total flexibilidad para nuevas implementaciones ayudando también en la gestión de errores a largo plazo",
    "home.projectFeatures.internationalization" : "Internacionalización",
    "home.projectFeatures.internationalization.sub" : "Internacionalización tanto en back como en frontend",
    "home.projectFeatures.exceptionHandling" : "Manejo de excepciones",
    "home.projectFeatures.exceptionHandling.sub" : "Manejo de excepciones personalizadas en backend y un disparador en el front para mostrar un mensaje en caso de haberlo",
    "home.projectFeatures.authentication" : "Autenticación",
    "home.projectFeatures.authentication.sub" : "Autenticación basada en OAUTH2, con multiples roles y endpoints limitados a scopes",
    "home.projectFeatures.security" : "Seguridad",
    "home.projectFeatures.security.sub" : "Spring security configurado para tener una aplicación securizada pero flexible",
    "home.projectFeatures.documentation" : "Documentación",
    "home.projectFeatures.documentation.sub" : "Gracias a la arquitectura hexagonal, el código puede usarse como documento, ya que los casos de uso son clases. Además, el uso de swagger para documentación de endpoints y proyecto de gihub (o apartado de <b>proyecto</b>) para más información",
    "home.pricingPlans" : "Precios",
    "home.pricingPlans.reinforcement" : "Refuerzo/Particulares",
    "home.pricingPlans.reinforcement.sub" : "Aprende a programar",
    "home.pricingPlans.reinforcement.item1" : "Aprende las bases de la programación orientada a objetos",
    "home.pricingPlans.reinforcement.item2" : "Avanza con el polimorfismo y las buenas prácticas",
    "home.pricingPlans.reinforcement.item3" : "Pasa al nivel experto con sincronismo, streams, lambdas...",
    "home.pricingPlans.reinforcement.item4" : "Desarrollo de frontend aprendiendo la base con JS y avanzando con Nuxt y Vue",
    "home.pricingPlans.poc" : "Pruebas de concepto",
    "home.pricingPlans.poc.sub" : "¿Necesitas alguna prueba de concepto?",
    "home.pricingPlans.poc.item1" : "Desarrollo de pruebas de concepto",
    "home.pricingPlans.poc.item2" : "Facilito una herramienta de creación de módulos CRUD para desarrollo rápido",
    "home.pricingPlans.poc.item3" : "Arquitectura hexagonal para reducir al mínimo el coste de cambios en las aplicaciones desarrolladas",
    "home.pricingPlans.poc.item4" : "<a href='https://github.com/txomin55/t-manager-module'>T-MANAGER-MODULE</a> y <a href='https://investdividend.com/'>INVEST DIVIDEND</a>",
    "home.pricingPlans.web" : "Páginas web",
    "home.pricingPlans.web.sub" : "Creación de páginas web",
    "home.pricingPlans.web.item1" : "Desarrollo de páginas web con WORDPRESS",
    "home.pricingPlans.web.item2" : "Posiciona tu negocio tanto en google como en google maps",
    "home.pricingPlans.web.item3" : "Hosting gestionado",
    "home.pricingPlans.web.item4" : "<a href='https://psk9.es/'>PSK9</a>, <a href='https://helmuga.eu/'>HELMUGA</a> y <a href='https://carolinamosquera.es/'>CAROLINA MOSQUERA</a>",
    "home.pricingPlans.askForIt" : "+Info",
    "home.me" : "Yo",
    "home.reachMe" : "Contacta conmigo",
    "home.mail" : "Correo",
    "home.firstName" : "Nombre",
    "home.lastName" : "Apellido",
    "home.yourText" : "Texto",
    "home.me.description" : "<p>He trabajado tanto en backend como en frontend durante más de 6 años en diferente empresas de Coruña, aprendiendo y aplicando las buenas prácticas del mundo de la programación, tanto a nivel de código como de arquitectura.</p><p><b>Ingeniero informático</b></p><p><b>Máster en Ingenieria de Sofware</b></p><p><b>Años de experiencia</b></p><p><b>Constantemente ampliando conocimientos</b></p>",
    "home.pricingPlans.description" : "Nada es fijo, esto solo son valores orientativos, todo depende de todo... :)",
    "project.motivation.title" : "Motivación",
    "project.motivation.description" : "La motivación de este proyecto es meramente personal, aunque creo que tiene bastantes usos tanto didácticos como profesionales. Basado en el framework <b>SpringBoot</b> para todo el backend y <b>Vue</b> para el frontend. El propósito es tener un ejemplo de una arquitectura limpia y preparada para poder empezar a desarrollar sin tener que lidiar con temas como la autenticación, manejo de excepciones, internacionalización etc. El proyecto está pensado para ser usado como microservicio y microfrontend, gracias a Vue, la aplicación web es una <b>SPA</b> que expone todo el js compilado (webpack) en una ruta accesible por una petición get, así pudiendo cargar el js del proyecto y pintarlo en un div en concreto de una aplicación mayor (ej: un dashboard).",
    "project.structure.title" : "Estructura",
    "project.structure.description" : "<p>La Arquitectura Hexagonal, dada a conocer por Alistair Cockburn — y también conocida como arquitectura de puertos y adaptadores — , tiene como principal motivación separar nuestra aplicación en distintas capas o regiones con su propia responsabilidad. De esta manera consigue desacoplar capas de nuestra aplicación permitiendo que evolucionen de manera aislada. Además, tener el sistema separado por responsabilidades nos facilitará la reutilización.</p><p>Gracias a este desacoplamiento obtenemos también la ventaja de poder testear estas capas sin que intervengan otras externas, falseando el comportamiento con dobles de pruebas, por ejemplo. Esta arquitectura se suele representar con forma de hexágono, pero el número de lados no es lo que importa, sino lo que estos representan. Cada lado representa un puerto hacia dentro o fuera de la aplicación. Por ejemplo, un puerto puede ser el HTTP, y hacer peticiones a nuestra aplicación, otro puerto puede ser el SOAP y también hace peticiones a la aplicación. Otro puede ser un servidor de base de datos en donde persistir los datos de nuestro dominio.</p><p>La Arquitectura Hexagonal propone que nuestro dominio sea el núcleo de las capas y que este no se acople a nada externo. En lugar de hacer uso explícito y mediante el principio de inversión de dependencias nos acoplamos a contratos (interfaces o puertos) y no a implementaciones concretas.</p><p>A grandes rasgos, y si mucho detalle, lo que propone es que nuestro núcleo sea visto como una API con unos contratos bien especificados. Definiendo puertos o puntos de entrada e interfaces (adaptadores) para que otros módulos (UI, BBDD, Test) puedan implementarlas y comunicarse con la capa de negocio sin que ésta deba saber el origen de la conexión. Esto es lo llamado puertos y adaptadores, que podrían ser definidos de la siguiente manera: Puerto: definición de una interfaz pública. Adapter: especialización de un puerto para un contexto concreto.</p><p>Fuente: <a href='https://medium.com/@edusalguero/arquitectura-hexagonal-59834bb44b7f' class='uri'>https://medium.com/@edusalguero/arquitectura-hexagonal-59834bb44b7f</a></p><figure><img src='images/arquitectura.png' style='width:100%' title='Arquitectura hexagonal' alt='' /><figcaption>arquitectura-hexagonal</figcaption></figure><p>El proyecto se define por diferentes submodulos de Maven:</p><ul><li><p><strong>Loader:</strong> Es el encargado de cargar la aplicación, solo contiene la clase que arranca la aplicación de SpringBoot, los yml de variables de entorno por perfil y las configuraciones de los adaptadores de los puertos. Para esto último se usan las clases de configuración FooApplicationConfiguration y FooInMemoryAdapterConfiguration o FooMongoAdapterConfiguration dependiendo de la variable de entorno “module.deploy.tech” definida a la hora de arrancar la aplicación (por defecto “in-memory”), también existe otra variable con nombre “module.deploy.external-communication-tech” que por defecto es “rest” y sirve para usar los beans de configuración de comunicación entre microproyectos por REST (esto está pensado para implementar kafka, rabbit…). Para gestionar el tema de los perfiles (tanto el de Maven como el Spring) hay que mirar el pom.xml del módulo padre, donde se definen los perfiles de Maven y lo asocian al perfil Spring seteando los parámetros spring.profiles.active (usado para seleccionar el yml adecuado al perfil) y npm.build (usado en el proyecto frontend para compilar). Antes de seleccionar el el fichero según el perfil, se carga el application.yml que a su vez coge el valor de spring.profile.active y se lo setea a Spring, así pudiendo coger el fichero correspondiente al perfil (application-develop por defecto).</p></li><li><p><strong>Web:</strong> El submódulo Web es el encargado de copiar en su carpeta resources el proyecto del Frontend y a también de definir todas las politicas de seguridad, beans, traducciones, controladores (API) etc. Se puede decir que es el módulo más complejo de todos. Gracias a Springboot y sus dependencias el proyecto web está configurado para coger lo que tenga en resources, pero en este caso, antes de mostrar el index.html ubicado en la carpeta public (junto con el js y css compilado del Frontend) se tiene que realizar el logueo con el servidor OAuth. Para ello se define en el MainController.java que cuando vayamos al classpath '/' redireccionemos a 'auth/authorize' en vez de enseñar el index (implementaciones en AuthController.java); para realizar esta acción se usan los certificados ubicados en la carpeta 'publicKey', toda la configuración relacionada con OAuth está en el OAuth2ResourceServerConfigJwt.java. Una vez nos logueamos de forma satisfactoria, la ruta de redirección definida por el cliente de OAuth será la de '/init' que ese nos mostrará el index.html y ejecutará el js compilado (module.js) cuando se cargue.</p></li><li><p><strong>Frontend (UI):</strong> Se trata de un proyecto muy simple de maven con todo lo necesario para ejecutar una aplicación de Vue, aquí se ubican (además de las carpetas de ficheros .js y .vue) el package.json (donde se definen los comandos que se pueden ejecutar), los ficheros de configuración .env.development y env.production (desde el comando de package.json se define el entorno a utilizar y dependiendo de esa variable se coge un fichero u otro) donde se definen algunos parámetros según el entorno, el vue.config.js (donde se define el proxy para desarrollo en local, evitar el hashing, el path del proyecto y que genere un solo .js con todo lo necesario para ser utilizado como microfrontend) y el pom.xml (donde en la fase de build se ejecuta el plugin frontend-maven-plugin para ejecutar comandos de node y npm, en caso de no tener estos instalados, los descarga, y por último se lanza el comando adecuado npm.build al perfil que se usa, definido en el pom.xml del proyecto raíz.).</p></li><li><p><strong>Application:</strong> Donde se define toda la lógica del flujo de cada caso de uso, usa los adaptadores de entrada (implementados por la capa web) para ejecutar el flujo adecuado del caso de uso independientemente de las adaptaciones de los puertos, manteniendo la lógica de negocio limpia de dependencias innecesarias.</p></li><li><p><strong>Domain:</strong> El encargado de aalmacenar los modelos que la capa de aplicación usa, independientemente del motor de bbdd que se use, este no depende de ninguna tecnología.</p></li><li><p><strong>Infrastrucure:</strong> Es quien implementa los puertos de salida expuestos por la capa de aplicación, en este caso están los de persistencia en memoria y en MongoDB.</p></li></ul><p>La idea de las capas arriba descritas es la siguiente.</p><p><img src='images/diagrama-logico.png' style='width:100%' title='Diagrama lógico' alt='diagrama-logico' /></p><p>Un ejemplo de diagrama de clases y flujo sería el siguiente (un caso de uso de crear Foo). Se pueden observar las diferentes interacciones de las capas con los puertos y adaptadores y los objetos que cada uno utiliza para realizar su labor.</p><p><img src='images/diagramaClases.png' style='width:100%' style='width:100%' alt='diagrama de clases' /></p><p><img src='images/diagramaFlujo.png' style='width:100%' alt='diagrama de flujo' /></p>",
    "project.authentication.title" : "Autenticación",
    "project.authentication.description" : "<p>Credenciales de login para usuarios open-source son los siguientes.</p><p><div class='sourceCode'><pre class='sourceCode javascript'><code class='sourceCode javascript'>user : user-open-source</br>password: password-open-source</code></pre></div></p><p>Para ejecutar la autenticación, se usa una modificación del restTemplate para añadir el certificado SSL, ya que el servidor de autenticación y autorización tiene el mismo .p12 que todos los módulos, es este el que se incluye. La configuración se hace gracias a la clase de configuración RestTemplateConfiguration en el module-web.</p><p>En cambio, el caso del logout es diferente. Desde la aplicación module-frontend se envia una petición post al controlador de LogoutController.java y este devuelve la ruta de logout del servidor de OAUTH2 y la ruta de redirección al homepath del módulo, haciendo asi el efecto de volver a la pantalla de login pero con el formulario limpio, ya que el servidor se ocupa de eliminar la cookie de JSESSIONID por el camino.</p>",
    "project.frontend.title" : "Frontend",
    "project.frontend.description" : "<p>La parte visual de la aplicación se ha desarrollado con Vue gracias a la facilidad y rapidez del framework a la hora de desarollar.</p><h3 id='node'>Node</h3><p>La versión de node que se instala para el clean install es v10.16.0, la versión de npm no hace falta definirla</p><h3 id='comandos-npm'>Comandos NPM</h3><div class='sourceCode' id='cb1'><pre class='sourceCode javascript'><code class='sourceCode javascript'><span id='cb1-1'><a href='#cb1-1' aria-hidden='true'></a>npm install</span><span id='cb1-2'><a href='#cb1-2' aria-hidden='true'></a>npm run serve</span><span id='cb1-3'><a href='#cb1-3' aria-hidden='true'></a>npm run build</span><span id='cb1-4'><a href='#cb1-4' aria-hidden='true'></a>npm run lint</span></code></pre></div><p>Las fuentes del proyecto son de <a href='http://materialdesignicons.com/'>http://materialdesignicons.com/</a></p><h3 id='el-módulo'>El módulo</h3><p>El módulo launcher setea window.t_manager_access_token con su token de acceso y window.t_manager_access_token_validity con el tiempo de validez de este.</p><p>Si es un módulo nuevo y está incluido en el launcher, también hay que añadir que el módulo está ensamblado en el launcher con el objeto window.isModuleEnsambled con module:valor =&gt; {'t-manager-MODULE': true} para que luego el modulo pueda verificar si está o no incluido para asi llamar al servicio de recuperar el token por su cuenta o cogerlo de window.t_manager_access_token.</p><p>En el index.html tiene que existir un div con el id de store.state.module, osea el nombre del módulo que decidamos.</p><p>El main.js es el encargado de cargar e inicializar el frontend, en él se usa la librería común t-manager-commons para instalar componentes Vue, inicializar el refresco de token de oauth2 y la clase de Vuetify con los estilos del commons. Hace falta definir window.Vue = WindowVue y volver a ponerlo a nulo porque la libreria común del t-manager-commons es una libreria de Vue que espera que window.Vue esté seteado, pero luego los componentes se instalan en la instancia de Vue que se va a utilizar en este modulo; ya que al poder ir embebido en otra aplicación esto se tiene que diferenciar. Las traducciones que usa la aplicación, se añaden a las ya existentes en la librería, en caso de no existir el idioma, los componentes de esta no se verán con las etiquetas traducidas.</p><p>Los js router y store verifican que si la dependencia que van a usar esta ya en el objeto de Vue, no se use, esto también es para prevenir errores de plugins cargados más de una vez.</p><p>Las imagenes hay que cargarlas como se hace en el ejemplo porque en el momento en que la aplicación sea embebida, no hay otra forma de acceder a ellas.</p>",
    "project.backend.title" : "Backend",
    "project.backend.description" : "<p>Como ya se ha explicado antes, el backend sigue una estructura hexagonal, los siguientes apartados explican como se han desarrollado las partes 'conflictivas' o las que hay que entender bien de la aplicación.</p><h3 id='logging'>Logging</h3><p>Gracias a la anotación @EnableWebSecurity(debug = true), el proyecto escupe todos los parámetros necesarios de las peticiones recibidas por consola. Springboot por defecto trae una configuración de logging que puede sobreescribirse, eso se hace mediante el fichero logback.xml, pero en este caso, para evitar más ficheros de configuración, se usa el logback-spring.xml donde además podemos usar otras anotaciones de Spring (como por ejemplo el del perfil) para tener diferentes configuraciones según el perfil elegido.</p><h3 id='locale'>Locale</h3><p>En la clase WebMvcConfigurer se define el locale resolver, que en cada petición que recibe busca la cabecera 'Accept-language' para definir el locale en el que tiene que mostrar los mensajes. Esta cabecera se setea gracias a un interceptor de Axios en el main.js del frontend.</p><h3 id='gestión-de-excepciones'>Gestión de excepciones</h3><p>Las excepciones se recogen en CustomExceptionHandler, aquí es donde se transforman a CustomException para que el frontend reciba siempre los mismos campos independientemente del tipo de error.</p><h4 id='timeout'>Timeout</h4><p>El timeout está gestionado con el filtro TimeoutFilter en el proyecto web, este corta el hilo según el valor definido de 'module.timeoutValue' en el application.yml (5000ms por defecto).</p><h4 id='validaciones'>Validaciones</h4><p>Las rutas y objetos que se reciben en las peticiones se validacion con la anotación @Valid y en caso de no pasarla, el CustomExceptionHandler lo detecta, para un ejemplo ver el caso de createFoo en el proyecto web, donde recibe un objeto CreateFooWeb y el valor name es obligatorio, a su vez, se le dice la etiqueta a mostrar en el locale adecuado. Es una capa más de validación, ya que el frontend tambien valida esto.</p><h3 id='seguridad'>Seguridad</h3><p>Toda la gestión de la seguridad se lleva a cabo gracias a Spring security y la aplicación t-manager-oauth2-server ubicada en la nube.</p><h4 id='spring'>Spring</h4><p>Solo se securizan las rutas que contengan '/api/*' o '/api/**', todo lo demás es público, esto se debe a que la aplicación (en el frontend) usa el modo history, evitando así tener que usar los # en el path, por lo que si se quiere acceder por ejemplo a la ruta /home, esta no puede estar securizada; además, todas las peticiones que no sean de api, ni de swagger, ni de recursos, se redirigen al index.html, para así poder copiar y pegar rutas en el navegador y no tener problema.</p><h4 id='datos-de-keystore'>Datos de keystore</h4><p>La aplicación t-manager-oauth2-server usa de un certificado para que sus consumidores puedan confiar de donde vienen las peticiones.</p><div class='sourceCode' id='cb1'><pre class='sourceCode javascript'><code class='sourceCode javascript'><span id='cb1-1'><a href='#cb1-1' aria-hidden='true'></a>keystore name<span class='op'>:</span> t<span class='op'>-</span>manager</span><span id='cb1-2'><a href='#cb1-2' aria-hidden='true'></a>keypass<span class='op'>:</span> t<span class='op'>-</span>manager<span class='op'>-</span>password</span><span id='cb1-3'><a href='#cb1-3' aria-hidden='true'></a>store pass<span class='op'>:</span> t<span class='op'>-</span>manager<span class='op'>-</span>password</span></code></pre></div><h4 id='a-tener-en-cuenta-con-oauth2'>A tener en cuenta con OAUTH2</h4><p>El resourceId dado de alta en users de mongo tiene que tener el mismo que la aplicacion module en OAuth2ResourceServerConfigJwt -&gt; config.resourceId('foo');. Al acceder al path del proyecto en <a href='http://localhost:8002/module,'>http://localhost:8002/module,</a> se redirige a la página de login de la aplicación t-manager-oauth2-server donde después de introducir las credenciales se vuelve a redirigir a <a href='http://localhost:8002/module/init'>http://localhost:8002/module/init</a> que a su vez lo hace a <a href='http://localhost:8002/module/home.'>http://localhost:8002/module/home.</a> Para la autenticación y posterior autorización, se usa el flujo de código de oauth2 (<a href='https://www.oauth.com/oauth2-servers/access-tokens/authorization-code-request/).'>https://www.oauth.com/oauth2-servers/access-tokens/authorization-code-request/).</a> El frontend se ocupa de refrescar el token automaticatimante al hacer uso de la utilidades de la librería común t-manager-commons (esto sucede en el main.js de la capa frontend y al igual que el locale, se envia en todas las peticiones a api como cabecera Authorization).</p><h3 id='cors'>CORS</h3><p>Al tratarse de una SPA con intención de ser usada como microservicio y microfrontend, el CORS debe permitir absolutamente todo, ya que en caso de que un usuario no identificado quiera acceder a un recurso del api no podrá por no tener el token de autenticación.</p><h3 id='llamadas-a-api-rest'>LLAMADAS A API REST</h3><p>Para poder consumir el api rest que generan los módulos te t-manager, hay que añadir en ellos el certificado SSL para poder hacer llamadas a rutas con HTTPS, por ello se usa la utilidad CustomRestTemplate que se define en el paquete 'rest' del módulo de infrastructure, para luego usarlo como ejemplo en la implementación para la obtención de Bar (en GetBarRestAdapter).</p><h3 id='swagger'>Swagger</h3><p>El swagger está montado para soportar Oauth2, por lo que en caso de querer llamar al API hay que loguearse en el icono de candado y luego añadir los parametros necesarios a la petición, su configuración se encuentra en SwaggerConfiguration.java (en el proyecto Web).</p><div class='sourceCode' id='cb1'><pre class='sourceCode javascript'><code class='sourceCode javascript'><span id='cb1-1'><a href='#cb1-1' aria-hidden='true'></a>http<span class='op'>:</span><span class='co'>//localhost:8002/module/swagger-ui.html</span></span></code></pre></div></p>",
    "project.compilation.title" : "Compilación",
    "project.compilation.description" : "<p>Los perfiles de compilado y ejecución de la aplicación son los siguientes:</p><ul><li><strong>develop</strong> (servidor en local)</li><li><strong>production</strong> (sevidor en IP especificada en el fichero application-production.yml)</li><li><strong>kubernetes</strong> (servidor kubernetes)</li></ul><p>Para compilar este proyecto hay que situarse en el proyecto raíz y ejecutar el siguiente comando, por defecto el perfil que se usa es el 'develop' pero existen otros 2 (explicados anteriormente):</p><div class='sourceCode' id='cb1'><pre class='sourceCode bash'><code class='sourceCode bash'><span id='cb1-1'><a href='#cb1-1' aria-hidden='true'></a><span class='ex'>mvn</span> clean install -Pproduction</span></code></pre></div><p>NOTA: Al tratarse un proyecto multimodulo de Maven, la compilación de los hijos del proyecto (web, application, loader...) dependen de la versión definida en el padre, esto se hace con la propiedad 'revision' y para que a la hora de ejecución, el módulo de loader tenga la versión del padre, hace falta usar el plugin de 'flatten-maven-plugin' para pasar los datos del padre a los hijos, esta configuración se ubica en el pom del proyecto padre.</p>",
    "project.execution.title" : "Ejecución",
    "project.execution.description" : "<p>La aplicación dispone de 2 tipos de implementación en lo que a persistencia se refiere, esta variable se setea con el nombre de module.build.tech:</p><ul><li><strong>in-memory</strong> (implementación de bbdd en memoria)</li><li><strong>mongo</strong> (implementación de bbdd de mongo)</li></ul><p>Para la comunicación entre modulos, solo dispone de la siguiente implementación, pero aquí se pueden configurar otros como Kafka, Rabbit... , esta variable se setea con el nombre de module.build.external-communication-tech:</p><ul><li><strong>rest</strong> (servidor kubernetes)</li></ul><p>Para ejecutar este proyecto hay que situarse en el proyecto loader y ejecutar (así usariamos la implementación de persistencia en mongo en vez de la de por defecto de en memoria):</p><div class='sourceCode' id='cb1'><pre class='sourceCode bash'><code class='sourceCode bash'><span id='cb1-1'><a href='#cb1-1' aria-hidden='true'></a><span class='ex'>mvn</span> spring-boot:run -Dspring.profiles.active=production -Dmodule.build.tech=mongo</span></code></pre></div> <h3>HTTPS</h3><p>En caso de lanzar la aplicación en el entorno de 'production', la aplicación se lanzará en con el protocolo HTTPS. Para ello usa el .p12 ubicado en la carpeta keystore en los resources del module-loader. Además, se añaden las configuraciones necesarias en el applicacion-production.yml para que el tomcat que se despliga tenga los datos necesarios. Este certificado es autofirmado y tiene el SAN de localhost y la ip 18.194.82.207 (la del servidor de Amazon). En caso de querer crear uno nuevo para otro servidor, en la carpeta de JAVA_HOME:</p><div class='sourceCode' id='cb1'><pre class='sourceCode bash'><code class='sourceCode bash'><span id='cb1-1'><a href='#cb1-1' aria-hidden='true'></a><span class='ex'>keytool</span> -genkeypair -alias t-manager -keyalg RSA -keysize 2048 -storetype PKCS12 -keystore t-manager.p12 -validity 9999 -ext san=dns:localhost,ip:18.194.82.207</span></code></pre></div><p>NOTA: Existe un pequeño truco en el pom del modulo web donde se dice que no se use el filtrado con el fichero .p12, sino Maven de forma automática lo modifica y da errores al lanzar el JAR.</p>",
    "$vuetify.badge" : "Placa",
    "$vuetify.close" : "Cerrar",
    "$vuetify.dataIterator.noResultsText" : "Ningún elemento coincide con la búsqueda",
    "$vuetify.dataIterator.loadingText" : "Cargando...",
    "$vuetify.dataTable.itemsPerPageText" : "Filas por página:",
    "$vuetify.dataTable.ariaLabel.sortDescending" : ": Orden descendente.",
    "$vuetify.dataTable.ariaLabel.sortAscending" : ": Orden ascendente.",
    "$vuetify.dataTable.ariaLabel.sortNone" : ": Sin ordenar.",
    "$vuetify.dataTable.ariaLabel.activateNone" : "Pulse para quitar orden.",
    "$vuetify.dataTable.ariaLabel.activateDescending" : "Pulse para ordenar descendente.",
    "$vuetify.dataTable.ariaLabel.activateAscending" : "Pulse para quitar orden.",
    "$vuetify.dataTable.sortBy" : "Ordenado por",
    "$vuetify.dataFooter.itemsPerPageText" : "Elementos por página:",
    "$vuetify.dataFooter.itemsPerPageAll" : "Todos",
    "$vuetify.dataFooter.nextPage" : "Página siguiente",
    "$vuetify.dataFooter.prevPage" : "Página anterior",
    "$vuetify.dataFooter.firstPage" : "Primera página",
    "$vuetify.dataFooter.lastPage" : "Última página",
    "$vuetify.dataFooter.pageText" : "{0}-{1} de {2}",
    "$vuetify.datePicker.itemsSelected" : "{0} seleccionados",
    "$vuetify.noDataText" : "No hay datos disponibles",
    "$vuetify.carousel.prev" : "Visual anterior",
    "$vuetify.carousel.next" : "Visual siguiente",
    "$vuetify.carousel.ariaLabel.delimiter": "Carousel slide {0} of {1}",
    "$vuetify.calendar.moreEvents" : "{0} más",
    "$vuetify.fileInput.counter" : "{0} archivos",
    "$vuetify.fileInput.counterSize" : "{0} archivos ({1} en total)",
    "$vuetify.timePicker.am" : "AM",
    "$vuetify.timePicker.pm" : "PM"
}
